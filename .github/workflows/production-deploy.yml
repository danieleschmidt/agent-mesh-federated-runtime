name: Production Deployment Pipeline

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
        - global

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PYTHON_VERSION: "3.12"

jobs:
  # ================================
  # Quality Gates and Testing
  # ================================
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-deploy: ${{ steps.deploy-check.outputs.should-deploy }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements*.txt') }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        pip install pytest pytest-asyncio prometheus-client psutil

    - name: Run comprehensive tests
      run: |
        python tests/test_comprehensive.py

    - name: Security scan
      run: |
        pip install bandit safety
        bandit -r src/ -f json -o security-report.json || true
        safety check --json --output safety-report.json || true

    - name: Code quality checks
      run: |
        pip install black flake8 mypy
        black --check src/ tests/
        flake8 src/ tests/
        mypy src/ --ignore-missing-imports || true

    - name: Generate version
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION="main-$(git rev-parse --short HEAD)"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Check deployment conditions
      id: deploy-check
      run: |
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == refs/tags/* ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

  # ================================
  # Multi-Architecture Build
  # ================================
  build:
    name: Build Multi-Arch Images
    runs-on: ubuntu-latest
    needs: quality-gates
    if: needs.quality-gates.outputs.should-deploy == 'true'
    strategy:
      matrix:
        target: [production, edge, gpu, monitoring]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha
        labels: |
          org.opencontainers.image.title=Agent Mesh Federated Runtime
          org.opencontainers.image.description=Quantum-inspired federated runtime for multi-agent systems
          org.opencontainers.image.vendor=Terragon Labs

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        target: ${{ matrix.target }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}-${{ matrix.target }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.quality-gates.outputs.version }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}

  # ================================
  # Security Scanning
  # ================================
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: build
    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.quality-gates.outputs.version }}-production
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

  # ================================
  # Staging Deployment
  # ================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-gates, build]
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.agent-mesh.terragon.ai
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}

    - name: Deploy to staging
      run: |
        # Update image tags in deployment
        sed -i "s|ghcr.io/your-org/agent-mesh-federated-runtime:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.quality-gates.outputs.version }}-production|g" k8s/deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/hpa.yaml
        
        # Wait for rollout
        kubectl rollout status statefulset/agent-mesh -n agent-mesh --timeout=600s

    - name: Run smoke tests
      run: |
        # Wait for service to be ready
        sleep 30
        
        # Get service endpoint
        ENDPOINT=$(kubectl get svc agent-mesh -n agent-mesh -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        # Run health checks
        curl -f http://$ENDPOINT:8000/health || exit 1
        curl -f http://$ENDPOINT:8000/ready || exit 1

  # ================================
  # Production Deployment
  # ================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quality-gates, build, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/') || github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://agent-mesh.terragon.ai
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.PRODUCTION_KUBECONFIG }}

    - name: Blue-Green Deployment
      run: |
        # Create blue-green deployment script
        cat << 'EOF' > deploy-blue-green.sh
        #!/bin/bash
        set -e
        
        NAMESPACE="agent-mesh"
        NEW_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.quality-gates.outputs.version }}-production"
        
        # Create green deployment
        kubectl patch statefulset agent-mesh -n $NAMESPACE -p '{"spec":{"template":{"spec":{"containers":[{"name":"mesh-node","image":"'$NEW_IMAGE'"}]}}}}'
        
        # Wait for rollout
        kubectl rollout status statefulset/agent-mesh -n $NAMESPACE --timeout=600s
        
        # Health check
        sleep 60
        kubectl get pods -n $NAMESPACE -l app.kubernetes.io/name=agent-mesh
        
        echo "Production deployment completed successfully"
        EOF
        
        chmod +x deploy-blue-green.sh
        ./deploy-blue-green.sh

    - name: Post-deployment validation
      run: |
        # Comprehensive health checks
        python scripts/integration-health-check.py --environment production

  # ================================
  # Global Deployment
  # ================================
  deploy-global:
    name: Deploy Globally
    runs-on: ubuntu-latest
    needs: [quality-gates, build, deploy-production]
    if: github.event.inputs.environment == 'global' || (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'global'))
    environment:
      name: global
      url: https://global.agent-mesh.terragon.ai
    strategy:
      matrix:
        region: [us-east-1, us-west-2, eu-west-1, ap-southeast-1, ap-northeast-1]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl for ${{ matrix.region }}
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets[format('KUBECONFIG_{0}', matrix.region)] }}

    - name: Deploy to ${{ matrix.region }}
      run: |
        # Region-specific configuration
        export REGION=${{ matrix.region }}
        export GLOBAL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.quality-gates.outputs.version }}-production"
        
        # Update deployment for global configuration
        envsubst < k8s/deployment.yaml | kubectl apply -f -
        kubectl apply -f k8s/hpa.yaml
        
        # Wait for regional deployment
        kubectl rollout status statefulset/agent-mesh -n agent-mesh --timeout=600s

    - name: Configure global load balancing
      if: matrix.region == 'us-east-1'  # Run only once
      run: |
        # Configure global load balancer and CDN
        echo "Configuring global distribution..."
        # This would integrate with your CDN provider (CloudFlare, AWS CloudFront, etc.)

  # ================================
  # Performance Testing
  # ================================
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    needs: deploy-production
    if: startsWith(github.ref, 'refs/tags/')
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run performance benchmarks
      run: |
        python scripts/benchmark.py --environment production
        python scripts/check_performance_regression.py

  # ================================
  # Rollback on Failure
  # ================================
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-production, performance-test]
    if: failure() && (startsWith(github.ref, 'refs/tags/') || github.event.inputs.environment == 'production')
    environment:
      name: production
    steps:
    - name: Rollback production deployment
      run: |
        kubectl rollout undo statefulset/agent-mesh -n agent-mesh
        kubectl rollout status statefulset/agent-mesh -n agent-mesh --timeout=300s
        echo "Rollback completed"

  # ================================
  # Notification
  # ================================
  notify:
    name: Deployment Notifications
    runs-on: ubuntu-latest
    needs: [deploy-production, deploy-global]
    if: always()
    steps:
    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            text: "Agent Mesh Deployment",
            attachments: [{
              color: '${{ job.status }}' === 'success' ? 'good' : 'danger',
              fields: [{
                title: 'Environment',
                value: '${{ github.event.inputs.environment || "production" }}',
                short: true
              }, {
                title: 'Version',
                value: '${{ needs.quality-gates.outputs.version }}',
                short: true
              }, {
                title: 'Status',
                value: '${{ job.status }}',
                short: true
              }]
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}