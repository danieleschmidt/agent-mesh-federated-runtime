# Release Automation Workflow
# Handles automated releases, changelog generation, and artifact publishing
# 
# MANUAL SETUP REQUIRED:
# 1. Copy this file to .github/workflows/release.yml
# 2. Configure release secrets (GPG keys, registry tokens, etc.)
# 3. Set up semantic-release configuration
# 4. Configure package registry publishing

name: Release

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease
      skip_tests:
        description: 'Skip release tests'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: agent-mesh-federated-runtime

# Ensure only one release workflow runs at a time
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # =============================================================================
  # DETERMINE RELEASE STRATEGY
  # =============================================================================
  release-strategy:
    name: Determine Release Strategy
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      release_type: ${{ steps.check.outputs.release_type }}
      current_version: ${{ steps.check.outputs.current_version }}
      next_version: ${{ steps.check.outputs.next_version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for semantic versioning
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install semantic-release
      run: |
        npm install -g semantic-release @semantic-release/changelog @semantic-release/git
    
    - name: Analyze commits for release
      id: check
      run: |
        # Get current version
        current_version=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "current_version=$current_version" >> $GITHUB_OUTPUT
        
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Manual release
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "release_type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
          
          # Calculate next version based on input
          if [[ "${{ github.event.inputs.release_type }}" == "major" ]]; then
            next_version=$(echo $current_version | awk -F. '{printf("v%d.0.0", $1+1)}' | sed 's/v//')
          elif [[ "${{ github.event.inputs.release_type }}" == "minor" ]]; then
            next_version=$(echo $current_version | awk -F. '{printf("v%d.%d.0", $1, $2+1)}' | sed 's/v//')
          else
            next_version=$(echo $current_version | awk -F. '{printf("v%d.%d.%d", $1, $2, $3+1)}' | sed 's/v//')
          fi
          echo "next_version=$next_version" >> $GITHUB_OUTPUT
        else
          # Automatic release based on conventional commits
          semantic-release --dry-run > release-notes.txt 2>&1 || true
          
          if grep -q "The next release version is" release-notes.txt; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "release_type=auto" >> $GITHUB_OUTPUT
            next_version=$(grep "The next release version is" release-notes.txt | awk '{print $NF}')
            echo "next_version=$next_version" >> $GITHUB_OUTPUT
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "release_type=none" >> $GITHUB_OUTPUT
            echo "next_version=$current_version" >> $GITHUB_OUTPUT
          fi
        fi
    
    - name: Upload release analysis
      uses: actions/upload-artifact@v4
      with:
        name: release-analysis
        path: release-notes.txt

  # =============================================================================
  # PRE-RELEASE TESTING
  # =============================================================================
  pre-release-tests:
    name: Pre-release Testing
    runs-on: ubuntu-latest
    needs: release-strategy
    if: needs.release-strategy.outputs.should_release == 'true' && !inputs.skip_tests
    timeout-minutes: 45
    
    strategy:
      matrix:
        test-suite: [unit, integration, e2e, security]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[test]"
    
    - name: Run test suite
      run: |
        case "${{ matrix.test-suite }}" in
          "unit")
            pytest tests/unit/ -v --junitxml=test-results-unit.xml
            ;;
          "integration")
            pytest tests/integration/ -v --junitxml=test-results-integration.xml
            ;;
          "e2e")
            pytest tests/e2e/ -v --junitxml=test-results-e2e.xml
            ;;
          "security")
            bandit -r src/ -f json -o bandit-report.json
            safety check
            ;;
        esac
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.test-suite }}
        path: |
          test-results-*.xml
          bandit-report.json

  # =============================================================================
  # BUILD RELEASE ARTIFACTS
  # =============================================================================
  build-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: [release-strategy, pre-release-tests]
    if: always() && needs.release-strategy.outputs.should_release == 'true' && (needs.pre-release-tests.result == 'success' || needs.pre-release-tests.result == 'skipped')
    timeout-minutes: 30
    
    outputs:
      wheel-path: ${{ steps.build.outputs.wheel-path }}
      sdist-path: ${{ steps.build.outputs.sdist-path }}
      image-digest: ${{ steps.docker.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip build twine
    
    - name: Update version for release
      run: |
        # Update version in pyproject.toml or setup.py
        next_version="${{ needs.release-strategy.outputs.next_version }}"
        
        if [ -f "pyproject.toml" ]; then
          sed -i "s/version = \".*\"/version = \"$next_version\"/" pyproject.toml
        fi
        
        # Update version in __init__.py
        if [ -f "src/agent_mesh/__init__.py" ]; then
          sed -i "s/__version__ = \".*\"/__version__ = \"$next_version\"/" src/agent_mesh/__init__.py
        fi
    
    - name: Build Python packages
      id: build
      run: |
        python -m build
        
        # Get build artifact paths
        wheel_path=$(ls dist/*.whl)
        sdist_path=$(ls dist/*.tar.gz)
        
        echo "wheel-path=$wheel_path" >> $GITHUB_OUTPUT
        echo "sdist-path=$sdist_path" >> $GITHUB_OUTPUT
        
        # Verify packages
        twine check dist/*
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Build and push Docker image
      id: docker
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.release-strategy.outputs.next_version }}
          ${{ env.REGISTRY }}/${{ github.repository }}:latest
        labels: |
          org.opencontainers.image.version=${{ needs.release-strategy.outputs.next_version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ steps.meta.outputs.created }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        build-args: |
          VERSION=${{ needs.release-strategy.outputs.next_version }}
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
    
    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.release-strategy.outputs.next_version }}
        format: spdx-json
        output-file: sbom.spdx.json
    
    - name: Sign artifacts
      if: env.GPG_PRIVATE_KEY != ''
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        echo "$GPG_PRIVATE_KEY" | gpg --batch --import
        
        # Sign Python packages
        for file in dist/*; do
          gpg --batch --yes --detach-sign --armor --passphrase "$GPG_PASSPHRASE" "$file"
        done
        
        # Sign SBOM
        gpg --batch --yes --detach-sign --armor --passphrase "$GPG_PASSPHRASE" sbom.spdx.json
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-artifacts
        path: |
          dist/
          sbom.spdx.json
          sbom.spdx.json.asc

  # =============================================================================
  # CREATE RELEASE
  # =============================================================================
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [release-strategy, build-artifacts]
    timeout-minutes: 15
    
    permissions:
      contents: write
      packages: write
      pull-requests: write
      issues: write
    
    outputs:
      release-url: ${{ steps.release.outputs.html_url }}
      upload-url: ${{ steps.release.outputs.upload_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install semantic-release
      run: |
        npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github
    
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-artifacts
        path: ./artifacts
    
    - name: Generate changelog
      run: |
        # Generate changelog for this release
        current_version="${{ needs.release-strategy.outputs.current_version }}"
        next_version="${{ needs.release-strategy.outputs.next_version }}"
        
        echo "# Release Notes for v$next_version" > RELEASE_NOTES.md
        echo "" >> RELEASE_NOTES.md
        
        # Get commits since last release
        git log --pretty=format:"- %s (%h)" $current_version..HEAD >> RELEASE_NOTES.md
        
        echo "" >> RELEASE_NOTES.md
        echo "## Artifacts" >> RELEASE_NOTES.md
        echo "- Python wheel and source distribution" >> RELEASE_NOTES.md
        echo "- Docker image: \`${{ env.REGISTRY }}/${{ github.repository }}:$next_version\`" >> RELEASE_NOTES.md
        echo "- SBOM (Software Bill of Materials)" >> RELEASE_NOTES.md
    
    - name: Create GitHub Release
      id: release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ needs.release-strategy.outputs.next_version }}
        release_name: Release v${{ needs.release-strategy.outputs.next_version }}
        body_path: RELEASE_NOTES.md
        draft: false
        prerelease: ${{ contains(needs.release-strategy.outputs.next_version, 'rc') || contains(needs.release-strategy.outputs.next_version, 'beta') || contains(needs.release-strategy.outputs.next_version, 'alpha') }}
    
    - name: Upload Python wheel
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.release.outputs.upload_url }}
        asset_path: ./artifacts/dist/*.whl
        asset_name: agent_mesh_federated_runtime-${{ needs.release-strategy.outputs.next_version }}-py3-none-any.whl
        asset_content_type: application/zip
    
    - name: Upload source distribution
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.release.outputs.upload_url }}
        asset_path: ./artifacts/dist/*.tar.gz
        asset_name: agent_mesh_federated_runtime-${{ needs.release-strategy.outputs.next_version }}.tar.gz
        asset_content_type: application/gzip
    
    - name: Upload SBOM
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.release.outputs.upload_url }}
        asset_path: ./artifacts/sbom.spdx.json
        asset_name: sbom.spdx.json
        asset_content_type: application/json

  # =============================================================================
  # PUBLISH TO PACKAGE REGISTRIES
  # =============================================================================
  publish-packages:
    name: Publish Packages
    runs-on: ubuntu-latest
    needs: [release-strategy, create-release]
    timeout-minutes: 15
    
    environment:
      name: pypi
      url: https://pypi.org/project/agent-mesh-federated-runtime/
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-artifacts
        path: ./artifacts
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Install publishing tools
      run: |
        python -m pip install --upgrade pip twine
    
    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        # Verify packages one more time
        twine check artifacts/dist/*
        
        # Publish to PyPI
        twine upload artifacts/dist/* --verbose
    
    - name: Publish to GitHub Packages
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
        TWINE_REPOSITORY_URL: https://upload.pypi.org/legacy/
      run: |
        # Note: Adjust repository URL for GitHub Packages if needed
        # twine upload --repository-url https://upload.pypi.org/legacy/ artifacts/dist/*
        echo "GitHub Packages publishing would happen here"

  # =============================================================================
  # POST-RELEASE TASKS
  # =============================================================================
  post-release:
    name: Post-release Tasks
    runs-on: ubuntu-latest
    needs: [release-strategy, create-release, publish-packages]
    if: always() && needs.create-release.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update documentation
      run: |
        # Update version in documentation
        next_version="${{ needs.release-strategy.outputs.next_version }}"
        
        # Update README badges
        sed -i "s/version-[0-9.]*/version-$next_version/" README.md
        
        # Update installation instructions
        sed -i "s/agent-mesh-federated-runtime==[0-9.]*/agent-mesh-federated-runtime==$next_version/" docs/**/*.md || true
    
    - name: Create documentation update PR
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: |
          docs: update documentation for v${{ needs.release-strategy.outputs.next_version }}
          
          - Update version references in README
          - Update installation instructions
          - Auto-generated post-release update
        title: 'ðŸ“ Update Documentation for v${{ needs.release-strategy.outputs.next_version }}'
        body: |
          ## Documentation Updates for Release v${{ needs.release-strategy.outputs.next_version }}
          
          This PR updates documentation to reflect the new release version.
          
          ### Changes
          - Updated version badges in README
          - Updated installation instructions
          - Version references throughout documentation
          
          ---
          
          ðŸ¤– This PR was created automatically after the release workflow.
        branch: post-release/update-docs-v${{ needs.release-strategy.outputs.next_version }}
        delete-branch: true
        labels: |
          documentation
          post-release
          automated
    
    - name: Notify team of release
      run: |
        echo "## ðŸŽ‰ Release v${{ needs.release-strategy.outputs.next_version }} Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Release Assets" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ“¦ [GitHub Release](${{ needs.create-release.outputs.release-url }})" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ [PyPI Package](https://pypi.org/project/agent-mesh-federated-runtime/${{ needs.release-strategy.outputs.next_version }}/)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ³ [Docker Image](${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.release-strategy.outputs.next_version }})" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "- Review and merge documentation updates" >> $GITHUB_STEP_SUMMARY
        echo "- Update deployment environments" >> $GITHUB_STEP_SUMMARY
        echo "- Announce release to stakeholders" >> $GITHUB_STEP_SUMMARY
    
    - name: Send Slack notification
      if: env.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            "text": "ðŸŽ‰ New release published!",
            "attachments": [{
              "color": "good",
              "fields": [{
                "title": "Version",
                "value": "v${{ needs.release-strategy.outputs.next_version }}",
                "short": true
              }, {
                "title": "Release",
                "value": "<${{ needs.create-release.outputs.release-url }}|View on GitHub>",
                "short": true
              }]
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}