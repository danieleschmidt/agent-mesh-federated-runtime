# Continuous Deployment Workflow for Agent Mesh Federated Runtime
# This workflow handles automated deployments to different environments
# 
# MANUAL SETUP REQUIRED:
# 1. Copy this file to .github/workflows/cd.yml
# 2. Configure deployment secrets and environment variables
# 3. Set up deployment environments in GitHub repository settings
# 4. Configure registry authentication and Kubernetes access

name: Continuous Deployment

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: agent-mesh-federated-runtime
  HELM_VERSION: '3.12.0'
  KUBECTL_VERSION: '1.28.0'

# Ensure only one deployment per environment
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: false

jobs:
  # =============================================================================
  # DETERMINE DEPLOYMENT STRATEGY
  # =============================================================================
  deployment-strategy:
    name: Determine Deployment Strategy
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.strategy.outputs.environment }}
      tag: ${{ steps.strategy.outputs.tag }}
      deploy_staging: ${{ steps.strategy.outputs.deploy_staging }}
      deploy_production: ${{ steps.strategy.outputs.deploy_production }}
      
    steps:
    - name: Determine deployment strategy
      id: strategy
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "deploy_staging=${{ github.event.inputs.environment == 'staging' }}" >> $GITHUB_OUTPUT
          echo "deploy_production=${{ github.event.inputs.environment == 'production' }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "deploy_staging=true" >> $GITHUB_OUTPUT
          echo "deploy_production=false" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          echo "deploy_staging=false" >> $GITHUB_OUTPUT
          echo "deploy_production=true" >> $GITHUB_OUTPUT
        else
          echo "environment=none" >> $GITHUB_OUTPUT
          echo "deploy_staging=false" >> $GITHUB_OUTPUT
          echo "deploy_production=false" >> $GITHUB_OUTPUT
        fi

  # =============================================================================
  # PRE-DEPLOYMENT TESTING
  # =============================================================================
  pre-deployment-tests:
    name: Pre-deployment Tests
    runs-on: ubuntu-latest
    needs: [deployment-strategy]
    if: ${{ !inputs.skip_tests && needs.deployment-strategy.outputs.environment != 'none' }}
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[test]"
    
    - name: Run smoke tests
      run: |
        pytest tests/e2e/test_smoke.py -v --tb=short
    
    - name: Run deployment compatibility tests
      run: |
        pytest tests/deployment/ -v --tb=short
    
    - name: Validate configurations
      run: |
        python scripts/validate-configs.py \
          --environment ${{ needs.deployment-strategy.outputs.environment }}

  # =============================================================================
  # BUILD AND PUSH CONTAINER IMAGES
  # =============================================================================
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [deployment-strategy, pre-deployment-tests]
    if: always() && (needs.pre-deployment-tests.result == 'success' || needs.pre-deployment-tests.result == 'skipped')
    timeout-minutes: 30
    
    permissions:
      contents: read
      packages: write
      id-token: write  # For OIDC
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-url: ${{ steps.build.outputs.image-url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Generate image metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}
        tags: |
          type=ref,event=branch
          type=ref,event=tag
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ needs.deployment-strategy.outputs.tag }}
        labels: |
          org.opencontainers.image.title=Agent Mesh Federated Runtime
          org.opencontainers.image.description=Decentralized P2P runtime for federated learning
          org.opencontainers.image.vendor=Terragon Labs
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        build-args: |
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ needs.deployment-strategy.outputs.tag }}
    
    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.deployment-strategy.outputs.tag }}
        format: spdx-json
        output-file: sbom.spdx.json
    
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.spdx.json

  # =============================================================================
  # SECURITY SCANNING
  # =============================================================================
  security-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [deployment-strategy, build-and-push]
    timeout-minutes: 15
    
    permissions:
      security-events: write
    
    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.deployment-strategy.outputs.tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'
    
    - name: Run Snyk container test
      uses: snyk/actions/docker@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.deployment-strategy.outputs.tag }}
        args: --severity-threshold=high
      continue-on-error: true

  # =============================================================================
  # STAGING DEPLOYMENT
  # =============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [deployment-strategy, build-and-push, security-scan]
    if: needs.deployment-strategy.outputs.deploy_staging == 'true'
    timeout-minutes: 20
    
    environment:
      name: staging
      url: https://staging.agent-mesh.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Configure Kubernetes context
      run: |
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl config current-context
    
    - name: Deploy to staging
      run: |
        export KUBECONFIG=kubeconfig
        helm upgrade --install agent-mesh-staging ./helm/agent-mesh \
          --namespace agent-mesh-staging \
          --create-namespace \
          --set image.repository=${{ env.REGISTRY }}/${{ github.repository }} \
          --set image.tag=${{ needs.deployment-strategy.outputs.tag }} \
          --set environment=staging \
          --set ingress.hostname=staging.agent-mesh.com \
          --values helm/agent-mesh/values-staging.yaml \
          --wait \
          --timeout=10m
    
    - name: Run post-deployment tests
      run: |
        export KUBECONFIG=kubeconfig
        kubectl wait --for=condition=available deployment/agent-mesh-staging \
          --namespace agent-mesh-staging --timeout=300s
        
        # Run health checks
        kubectl run test-pod --rm -i --restart=Never \
          --image=curlimages/curl:latest \
          --namespace agent-mesh-staging \
          -- curl -f http://agent-mesh-staging:8080/health
    
    - name: Update deployment status
      run: |
        echo "✅ Successfully deployed to staging environment" >> $GITHUB_STEP_SUMMARY
        echo "🔗 Staging URL: https://staging.agent-mesh.com" >> $GITHUB_STEP_SUMMARY
        echo "📊 Monitoring: https://grafana.staging.agent-mesh.com" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # PRODUCTION DEPLOYMENT
  # =============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deployment-strategy, build-and-push, security-scan]
    if: needs.deployment-strategy.outputs.deploy_production == 'true'
    timeout-minutes: 30
    
    environment:
      name: production
      url: https://agent-mesh.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Configure Kubernetes context
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl config current-context
    
    - name: Create backup
      run: |
        export KUBECONFIG=kubeconfig
        helm get values agent-mesh-production -n agent-mesh-production > backup-values.yaml
        kubectl create backup production-backup-$(date +%Y%m%d-%H%M%S) \
          --namespace agent-mesh-production || true
    
    - name: Deploy to production (Blue-Green)
      run: |
        export KUBECONFIG=kubeconfig
        
        # Deploy to green environment
        helm upgrade --install agent-mesh-production-green ./helm/agent-mesh \
          --namespace agent-mesh-production \
          --create-namespace \
          --set image.repository=${{ env.REGISTRY }}/${{ github.repository }} \
          --set image.tag=${{ needs.deployment-strategy.outputs.tag }} \
          --set environment=production \
          --set ingress.hostname=agent-mesh.com \
          --set deployment.strategy=green \
          --values helm/agent-mesh/values-production.yaml \
          --wait \
          --timeout=15m
    
    - name: Run production health checks
      run: |
        export KUBECONFIG=kubeconfig
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available deployment/agent-mesh-production-green \
          --namespace agent-mesh-production --timeout=600s
        
        # Run comprehensive health checks
        kubectl run production-health-check --rm -i --restart=Never \
          --image=${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.deployment-strategy.outputs.tag }} \
          --namespace agent-mesh-production \
          -- python scripts/health-check.py --comprehensive --timeout=120
    
    - name: Switch traffic to green deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        # Switch ingress to green deployment
        kubectl patch ingress agent-mesh-ingress \
          --namespace agent-mesh-production \
          --type='json' \
          -p='[{"op": "replace", "path": "/spec/rules/0/http/paths/0/backend/service/name", "value": "agent-mesh-production-green"}]'
        
        # Wait for traffic switch
        sleep 30
        
        # Verify traffic is flowing to new deployment
        kubectl run traffic-verification --rm -i --restart=Never \
          --image=curlimages/curl:latest \
          --namespace agent-mesh-production \
          -- curl -f https://agent-mesh.com/health
    
    - name: Monitor deployment for 5 minutes
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "Monitoring production deployment for 5 minutes..."
        for i in {1..5}; do
          echo "Minute $i/5: Checking application health..."
          kubectl run health-monitor-$i --rm -i --restart=Never \
            --image=curlimages/curl:latest \
            --namespace agent-mesh-production \
            -- curl -f https://agent-mesh.com/health
          sleep 60
        done
    
    - name: Cleanup old blue deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        # Remove old blue deployment
        helm uninstall agent-mesh-production-blue \
          --namespace agent-mesh-production || echo "Blue deployment not found"
        
        # Rename green to production
        helm upgrade agent-mesh-production ./helm/agent-mesh \
          --namespace agent-mesh-production \
          --reuse-values \
          --set deployment.strategy=production
    
    - name: Update deployment status
      run: |
        echo "✅ Successfully deployed to production environment" >> $GITHUB_STEP_SUMMARY
        echo "🔗 Production URL: https://agent-mesh.com" >> $GITHUB_STEP_SUMMARY
        echo "📊 Monitoring: https://grafana.agent-mesh.com" >> $GITHUB_STEP_SUMMARY
        echo "🚨 Alerts: https://alertmanager.agent-mesh.com" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # DEPLOYMENT NOTIFICATIONS
  # =============================================================================
  notify-deployment:
    name: Deployment Notifications
    runs-on: ubuntu-latest
    needs: [deployment-strategy, deploy-staging, deploy-production]
    if: always() && needs.deployment-strategy.outputs.environment != 'none'
    
    steps:
    - name: Determine deployment result
      id: result
      run: |
        if [[ "${{ needs.deploy-staging.result }}" == "success" || "${{ needs.deploy-production.result }}" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=Deployment failed" >> $GITHUB_OUTPUT
        fi
    
    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.result.outputs.status }}
        channel: '#deployments'
        text: |
          ${{ steps.result.outputs.message }}
          Environment: ${{ needs.deployment-strategy.outputs.environment }}
          Version: ${{ needs.deployment-strategy.outputs.tag }}
          Commit: ${{ github.sha }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    
    - name: Create GitHub deployment
      uses: chrnorm/deployment-action@v2
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        environment: ${{ needs.deployment-strategy.outputs.environment }}
        state: ${{ steps.result.outputs.status == 'success' && 'success' || 'failure' }}
        description: ${{ steps.result.outputs.message }}
    
    - name: Update monitoring dashboards
      if: steps.result.outputs.status == 'success'
      run: |
        # Update deployment annotations in Grafana
        curl -X POST "https://grafana.${{ needs.deployment-strategy.outputs.environment }}.agent-mesh.com/api/annotations" \
          -H "Authorization: Bearer ${{ secrets.GRAFANA_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d '{
            "text": "Deployment: ${{ needs.deployment-strategy.outputs.tag }}",
            "tags": ["deployment", "${{ needs.deployment-strategy.outputs.environment }}"],
            "time": '$(date +%s000)'
          }'